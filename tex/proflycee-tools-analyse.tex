% proflycee-tools-analyse.tex
% Copyright 2023  Cédric Pierquet
% This work may be distributed and/or modified under the
% conditions of the LaTeX Project Public License, either version 1.3
% of this license or (at your option) any later version.
% The latest version of this license is in
%   http://www.latex-project.org/lppl.txt
% and version 1.3 or later is part of all distributions of LaTeX
% version 2005/12/01 or later.

%%------SimplFrac nouvelle version
\NewDocumentCommand\ConversionFraction{ s O{} m }{%
	%*=moins sur le numérateur
	%2=argument.optionnel[d/t/dec=...]
	%3=argument mandataire {calcul ou fraction}
	\def\calculargument{\xintPRaw{\xintIrr{\xinteval{#3}}}}%on calcule et on transforme en A/B
	\IfSubStr{\calculargument}{/}%on teste si le symbole / apparaît
	{%si oui := fraction
		\StrBefore{\calculargument}{/}[\numerateur]%on extrait le numérateur
		\StrBehind{\calculargument}{/}[\denominateur]%on extrait le dénominateur
		\ifblank{#2}%
		{%
			\IfBooleanTF{#1}%
			{\ensuremath{\frac{\num{\numerateur}}{\num{\denominateur}}}}%
			{%
				\ifthenelse{\numerateur < 0}%
					{\ensuremath{-\frac{\num{\fpeval{abs(\numerateur)}}}{\num{\denominateur}}}}%
					{\ensuremath{\frac{\num{\numerateur}}{\num{\denominateur}}}}%
			}%
		}%
		{}%si l'argument optionnel est vide
		\IfStrEq{#2}{d}%
		{%
			\IfBooleanTF{#1}%
			{\ensuremath{\dfrac{\num{\numerateur}}{\num{\denominateur}}}}%
			{%
				\ifthenelse{\numerateur < 0}%
					{\ensuremath{-\dfrac{\num{\fpeval{abs(\numerateur)}}}{\num{\denominateur}}}}%
					{\ensuremath{\dfrac{\num{\numerateur}}{\num{\denominateur}}}}%
			}%
		}%
		{}%si l'argument optionnel est vide
		\IfStrEq{#2}{t}%
		{%
			\IfBooleanTF{#1}%
			{\ensuremath{\tfrac{\num{\numerateur}}{\num{\denominateur}}}}%
			{%
				\ifthenelse{\numerateur < 0}%
					{\ensuremath{-\tfrac{\num{\fpeval{abs(\numerateur)}}}{\num{\denominateur}}}}%
					{\ensuremath{\tfrac{\num{\numerateur}}{\num{\denominateur}}}}%
			}%
		}%
		{}%si l'argument optionnel est vide
		\IfStrEq{#2}{n}%
		{%
			%\IfBooleanTF{#1}%
			{\ensuremath{\nicefrac{\num{\numerateur}}{\num{\denominateur}}}}%
			%{%
			%	\ifthenelse{\numerateur < 0}%
			%		{\ensuremath{-\nicefrac{\num{\fpeval{abs(\numerateur)}}}{\num{\denominateur}}}}%
			%		{\ensuremath{\nicefrac{\num{\numerateur}}{\num{\denominateur}}}}%
			%}%
		}%
		{}%si l'argument optionnel est vide
		\IfSubStr{#2}{dec}%on veut la forme décimale
		{%
			\IfSubStr{#2}{=}%si on rajoute une précision
				{%
					\StrBehind{#2}{=}[\precdecimal]%
					\ensuremath{\num{\xintfloateval{round(#3,\precdecimal)}}}%
				}%
				{%
					\ensuremath{\num{\xintfloateval{#3}}}%
				}%
		}%
		{}%si l'argument optionnel est vide
	}{%si non := entier
		\num{\calculargument}%on affiche l'entier, avec le package siunitx
	}%
}

%%------AideTds
\defKV[aidetds]{%
	Code=\def\tdsparam{#1},%
	Couleur=\def\tdscouleur{#1},%
	Racines=\def\tdsracine{#1},%
	Largeur=\def\tdslarg{#1},%
	Hauteur=\def\tdshaut{#1}
}

\setKVdefault[aidetds]{%
	Code=da+,
	Couleur=red,%
	Largeur=2,%
	Hauteur=1,%
	Cadre=true,%
	Racines=2
}

\NewDocumentCommand\schematdsaff{ s m m m m }{%pour les droites (interne)
	% * = étoilée -> a négatif
	% #2 = couleur
	% #3 = largeur
	% #4 = hauteur
	% #5 = racine
	\IfBooleanTF{#1}%si étoile := droite qui descend
		{%
			\def\possgnavant{above right}\def\possgnapres{below left}\def\sgnavant{\strut+}\def\sgnapres{\strut-}%
			\draw[thick,#2] ({-0.5*#3},{0.5*#4})--({0.5*#3},{-0.5*#4});
		}
		{%
			\def\possgnavant{below right}\def\possgnapres{above left}\def\sgnavant{\strut-}\def\sgnapres{\strut+}%
			\draw[thick,#2] ({-0.5*#3},{-0.5*#4})--({0.5*#3},{0.5*#4});
		}
	\draw[#2] ({-0.5*#3},0) node[inner sep=0pt,\possgnavant=1pt,font=\scriptsize] {\textcircled{$\sgnavant$}};
	\draw[#2] ({0.5*#3},0) node[inner sep=0pt,\possgnapres=1pt,font=\scriptsize] {\textcircled{$\sgnapres$}};
	\draw[#2] (0,0) node[inner sep=0pt,above=3pt,font=\scriptsize] {$\strut#5$} ;
	\filldraw[#2] (0,0) circle[radius=2pt] ;
}

\NewDocumentCommand\schematdsparab{ m m m m m o }{%pour les paraboles (interne)
	% #1 = signe de a (1 ou -1) ?
	% #2 = couleur
	% #3 = largeur
	% #4 = hauteur
	% #5 = nb racine
	% #6 = liste racines (option)
	\xintifboolexpr{ #1 > 0 'and' #5 == 2 } %a>0 et delta>0
	{%
		\saveexpandmode\expandarg
		\StrCut{#6}{/}{\xun}{\xdeux}
		\restoreexpandmode
		\draw[thick,#2] ({-0.375*#3},{0.5*#4}) parabola bend (0,{-0.5*#4}) ({0.375*#3},{0.5*#4}) ;
		\draw[#2] ({-0.5*#3},0) node[above right=1pt,inner sep=0pt,font=\scriptsize] {\textcircled{$\strut+$}};
		\draw[#2] ({0.5*#3},0) node[above left=1pt,inner sep=0pt,font=\scriptsize] {\textcircled{$\strut+$}};
		\draw[#2] (0,0) node[below=1pt,inner sep=0pt,font=\scriptsize] {\textcircled{$\strut-$}};
		\filldraw[#2] ({0.2625*#3},0) circle[radius=2pt] node[below right=1pt,inner sep=0pt,font=\scriptsize] {$\strut\xdeux$};
		\filldraw[#2] ({-0.2625*#3},0) circle[radius=2pt] node[below left=1pt,inner sep=0pt,font=\scriptsize] {$\strut\xun$};%
	}
	{}
	\xintifboolexpr{ #1 < 0 'and' #5 == 2 } %a<0 et delta>0
	{%
		\saveexpandmode\expandarg
		\StrCut{#6}{/}{\xun}{\xdeux}
		\restoreexpandmode
		\draw[thick,#2] ({-0.375*#3},{-0.5*#4}) parabola bend (0,{0.5*#4}) ({0.375*#3},{-0.5*#4}) ;
		\draw[#2] ({-0.5*#3},0) node[below right=1pt,inner sep=0pt,font=\scriptsize] {\textcircled{$\strut-$}};
		\draw[#2] ({0.5*#3},0) node[below left=1pt,inner sep=0pt,font=\scriptsize] {\textcircled{$\strut-$}};
		\draw[#2] (0,0) node[above=1pt,inner sep=0pt,font=\scriptsize] {\textcircled{$\strut+$}};
		\filldraw[#2] ({0.2625*#3},0) circle[radius=2pt] node[above right=1pt,inner sep=0pt,font=\scriptsize] {$\strut\xdeux$};
		\filldraw[#2] ({-0.2625*#3},0) circle[radius=2pt] node[above left=1pt,inner sep=0pt,font=\scriptsize] {$\strut\xun$};%
	}
	{}
	\xintifboolexpr{ #1 > 0 'and' #5 == 1 } %a>0 et delta=0
	{%
		\draw[thick,#2] ({-0.375*#3},{0.5*#4}) parabola bend (0,0) ({0.375*#3},{0.5*#4}) ;
		\filldraw[#2] (0,0) circle[radius=2pt] node[below=3pt,inner sep=1pt,font=\scriptsize] {$#6$};
		\draw[#2] (0,0) node[above=3pt,inner sep=0pt,font=\scriptsize] {\textcircled{$\strut+$}};
	}
	{}
	\xintifboolexpr{ #1 < 0 'and' #5 == 1 } %a>0 et delta=0
	{%
		\draw[thick,#2] ({-0.375*#3},{-0.5*#4}) parabola bend (0,0) ({0.375*#3},{-0.5*#4}) ;
		\filldraw[#2] (0,0) circle[radius=2pt] node[above=3pt,inner sep=0pt,font=\scriptsize] {$#6$};
		\draw[#2] (0,0) node[below=3pt,inner sep=0pt,font=\scriptsize] {\textcircled{$\strut-$}};
	}
	{}
	\xintifboolexpr{ #1 > 0 'and' #5 == 0 } %a>0 et delta<0
	{%
		\draw[thick,#2] ({-0.375*#3},{0.5*#4}) parabola bend (0,{0.075*#4}) ({0.375*#3},{0.5*#4}) ;
		\draw[#2] (0,{0.075*#4}) node[above=2pt,inner sep=0pt,font=\scriptsize] {\textcircled{$\strut+$}};
	}
	{}
	\xintifboolexpr{ #1 < 0 'and' #5 == 0 } %a>0 et delta<0
	{%
		\draw[thick,#2] ({-0.375*#3},{-0.5*#4}) parabola bend (0,{-0.075*#4}) ({0.375*#3},{-0.5*#4}) ;
		\draw[#2] (0,{-0.075*#4}) node[below=2pt,inner sep=0pt,font=\scriptsize] {\textcircled{$\strut-$}};
	}
	{}
}

\NewDocumentCommand\MiniSchemaSignes{ s O{} D<>{} }{%
	\useKVdefault[aidetds]
	\setKV[aidetds]{#2}
	%simplification des codes
	\IfEq{\tdsparam}{da+}{\def\xcode{1}}{}
	\IfEq{\tdsparam}{da-}{\def\xcode{-1}}{}
	\IfEq{\tdsparam}{pa+d+}{\def\xcode{12}}{}
	\IfEq{\tdsparam}{pa-d+}{\def\xcode{-12}}{}
	\IfEq{\tdsparam}{pa+d0}{\def\xcode{11}}{}
	\IfEq{\tdsparam}{pa-d0}{\def\xcode{-11}}{}
	\IfEq{\tdsparam}{pa+d-}{\def\xcode{10}}{}
	\IfEq{\tdsparam}{pa-d-}{\def\xcode{-10}}{}
	%si commande étoilée := commande autonome
	\IfBooleanTF{#1}%
		{\begin{tikzpicture}[#3]}{}%
	%cadre si booléen true
	\ifboolKV[aidetds]{Cadre}
		{\draw[lightgray] ({-0.5*\tdslarg},{-0.5*\tdshaut}) rectangle ({0.55*\tdslarg},{0.5*\tdshaut}) ;}
		{}
	%restriction de la petite fenêtre
	\clip ({-0.5*\tdslarg},{-0.5*\tdshaut}) rectangle ({0.55*\tdslarg},{0.5*\tdshaut}) ;
	%axe (Ox)
	\draw[thick,->] ({-0.5*\tdslarg},0)--({0.55*\tdslarg},0);
	%1er degré a+ code = 1
	\ifnum\xcode=1
		\schematdsaff{\tdscouleur}{\tdslarg}{\tdshaut}{\tdsracine}
	\fi
	%1er degré a- code = -1
	\ifnum\xcode=-1
		\schematdsaff*{\tdscouleur}{\tdslarg}{\tdshaut}{\tdsracine}
	\fi
	%2d degré a+delta+ code = 12
	\ifnum\xcode=12
		\schematdsparab{1}{\tdscouleur}{\tdslarg}{\tdshaut}{2}[\tdsracine]
	\fi
	%2d degré a-delta+ code = -12
	\ifnum\xcode=-12
		\schematdsparab{-1}{\tdscouleur}{\tdslarg}{\tdshaut}{2}[\tdsracine]
	\fi
	%2d degré a+delta0 code = 11
	\ifnum\xcode=11
		\schematdsparab{1}{\tdscouleur}{\tdslarg}{\tdshaut}{1}[\tdsracine]
	\fi
	%2d degré a-delta0 code = -11
	\ifnum\xcode=-11
		\schematdsparab{-1}{\tdscouleur}{\tdslarg}{\tdshaut}{1}[\tdsracine]
	\fi
	%2d degré a+delta- code = 10
	\ifnum\xcode=10
		\schematdsparab{1}{\tdscouleur}{\tdslarg}{\tdshaut}{0}
	\fi
	%2d degré a-delta- code = -10
	\ifnum\xcode=-10
		\schematdsparab{-1}{\tdscouleur}{\tdslarg}{\tdshaut}{0}
	\fi
	\IfBooleanTF{#1}%
		{\end{tikzpicture}}{}%
}

%pour l'interaction avec tkz-tab
\defKV[aidetdstkz]{%
	Echelle=\def\tdstkzscale{#1},%
	Decal=\def\tdstkzoffset{#1}
}

\setKVdefault[aidetdstkz]{%
	Echelle=1,%
	Decal=1.25
}

\NewDocumentCommand\MiniSchemaSignesTkzTab{ o m O{0.85} O{1.5} }{%
	%#1 = codeaidetikz
	%#2 = numligne
	%#3 = échelle
	%#4 = décalage
	%\shorthandoff{:}\shorthandoff{!} %bizzzzzzzzare
	%\NoAutoSpacing
	\coordinate (ZZZ) at ($(T2#2)!.5!(T2\the\numexpr#2+1\relax)$) ;
	%\shorthandon{:}\shorthandon{!}
	\path (ZZZ.east) + (#4,0) pic[right,scale=#3,every node/.style={scale=#3}] {code={\MiniSchemaSignes[#1]}} ;
}

%%------TVISOLUTION
\defKV[dichoto]{%
	NomFct=\def\DHTnomfct{#1},%
	va=\def\DHTva{#1},%
	vb=\def\DHTvb{#1},%
	Precision=\def\DHTprec{#1},%
	NomSol=\def\DHTnomsol{#1},%
	Stretch=\def\DHTstretch{#1}
}

\setKVdefault[dichoto]{%
	NomFct=f,%
	Precision=2,%
	NomSol=\alpha,%
	Stretch=1.15,%
	Balayage=false,%
	Calculatrice=false,%
	Majuscule=true
}

\newcommand\SolutionTVI[3][]{%
	\useKVdefault[dichoto]%
	\setKV[dichoto]{#1}%
	\xintdeffloatfunc varfct(x) := #2 ;%
	\ifboolKV[dichoto]{Balayage}{\ifboolKV[dichoto]{Majuscule}{P}{p}ar balayage, on obtient }{}%
	\ifboolKV[dichoto]{Calculatrice}{\ifboolKV[dichoto]{Majuscule}{P}{p}ar calculatrice, on obtient }{}%
	\ensuremath{%
		\left\lbrace \begin{tblr}{stretch=\DHTstretch,colsep=1pt,rll}%
			{\DHTnomfct}{\left( \num{\DHTva} \right)} &\approx \num[minimum-decimal-digits=\DHTprec]{\xintFloatToDecimal{\xintfloateval{round(varfct(\DHTva),\DHTprec)}}} & \xintifGt{\xintfloateval{varfct(\DHTva)-#3}}{0}{> \num{#3}}{< \num{#3}} \: \\ %
			{\DHTnomfct}{\left( \num{\DHTvb} \right)} &\approx \num[minimum-decimal-digits=\DHTprec]{\xintFloatToDecimal{\xintfloateval{round(varfct(\DHTvb),\DHTprec)}}} & \xintifGt{\xintfloateval{varfct(\DHTvb)-#3}}{0}{> \num{#3}}{< \num{#3}} \:%
		\end{tblr}%
		\right|%
		\Rightarrow%
		\num{\DHTva} < \DHTnomsol < \num{\DHTvb}%
	}%
}

%%------SIMPLIFRACINES
\DeclareDocumentCommand\SimplificationRacine{ m }{% argument mandataire {calcul ou fraction}
	\xdef\calculargument{\xintIrr{\xinteval{#1}}}%
	\IfEndWith{\calculargument}{/1}%
	{%si c'est un entier !
		\xdef\calculargument{\xintiieval{#1}}%
		\xdef\ExtractRacStop{\xintiFloor{\xintfloateval{sqrt(\calculargument)}}}%
		\xintFor* ##1 in {\xintSeq{1}{\ExtractRacStop}}\do{%
			\xintifboolexpr{ \xintiiRem{\calculargument}{\xintiieval{##1*##1}} == 0}%si le carré divise
			{\xdef\ExtractRacID{##1}}%
			{}%
			}%
		\xdef\ExtracReste{\xintiieval{\calculargument/(\ExtractRacID*\ExtractRacID)}}%
		\ensuremath{\xintifboolexpr{\ExtractRacID == 1 && \ExtracReste == 1}%
			{1}%
			{ \xintifboolexpr{\ExtractRacID == 1}{}{\num{\xintiieval{\ExtractRacID}}}%
			\xintifboolexpr{\ExtracReste == 1}{}{\sqrt{\num{\ExtracReste}}} }}%
%			}%
	}%
	{%on va mettre sous forme a\sqrt(d)/b := buggue avec des millièmes...
		\StrBefore{\calculargument}{/}[\numerateur]%on extrait le numérateur
		\StrBehind{\calculargument}{/}[\denominateur]%on extrait le dénominateur
		\xdef\ExtractRacNNum{\xintiieval{\numerateur*\denominateur}}%
		\xdef\ExtractRacStop{\xintiFloor{\xintfloateval{sqrt(\ExtractRacNNum)}}}%
		\xintFor* ##1 in {\xintSeq{1}{\ExtractRacStop}}\do{%
			\xintifboolexpr{ \xintiiRem{\ExtractRacNNum}{\xintiieval{##1*##1}} == 0}%si le carré divise
			{\xdef\ExtractRacID{##1}}%
			{}
		}%
		\xdef\ExtractRacGCD{\xintiiGCD{\ExtractRacID}{\denominateur}}%
		\xdef\RacNumSimpl{\xintiieval{\ExtractRacID/\ExtractRacGCD}}%simpl num
		\xdef\RacDenomSimpl{\xintiieval{\denominateur/\ExtractRacGCD}}%
		\xdef\RacRacSimpl{\xintiieval{\ExtractRacNNum/(\ExtractRacID*\ExtractRacID)}}%
		\ensuremath{\frac{%
			\xintifboolexpr{\RacNumSimpl == 1 && \RacRacSimpl == 1}%
			{1}%
			{ \xintifboolexpr{\RacNumSimpl == 1}{}{\RacNumSimpl} \xintifboolexpr{\RacRacSimpl == 1}{}{\sqrt{\RacRacSimpl}} }%
			}%
			{ \RacDenomSimpl }}%
	}%
}

%%------DICHOTOMIE
\defKV[SolDichoto]{%
	Precision=\xdef\DICHOTOstep{#1},%
	Intervalle=\xdef\DICHOTOinterv{#1},%
	Variable=\xdef\DICHOTOvar{#1}
}

\setKVdefault[SolDichoto]{%
	Precision=2,%
	Variable=x,%
	Intervalle={0:10}
}

\NewDocumentCommand\ResolutionApprochee{ O{} m O{masolution} }{%1=options,2=equation,3=macro
	\useKVdefault[SolDichoto]%
	%extraction fonction + valeur
	\setKV[SolDichoto]{#1}%
	\IfSubStr{#2}{=}%on coupe mmb gauche / mmb droit
		{\StrCut{#2}{=}{\SolDiFCT}{\SolDiVal}}%
		{\xdef\SolDiFCT{#2}\xdef\SolDiVal{0}}%
	%création des variables temporaires
	\xintdeffloatfunc dichotovarfct(\DICHOTOvar) := \SolDiFCT ;%
	\StrCut{\DICHOTOinterv}{:}{\varvala}{\varvalb}%
	\xdef\varstep{\fpeval{10**(-\DICHOTOstep-1)}}%un chiffre en plus :-)
	%boucles
	\whiledo{\xintGt{\xintfloateval{\varvalb-\varvala-\varstep}}{0} = 1}%
	{%
		\xdef\varvalm{\xintfloateval{(\varvala+\varvalb)*0.5}}%
		\xintifboolexpr{\xintGt{\xintfloateval{(dichotovarfct(\varvala)-\SolDiVal)*(dichotovarfct(\varvalm)-\SolDiVal)}}{0}==1}%
			{\xdef\varvala{\fpeval{\varvalm}}}%
			{\xdef\varvalb{\fpeval{\varvalm}}}%
	}%
	\xdef\varvalm{\xintfloateval{(\varvala+\varvalb)*0.5}}%
	\xdef\vartmpmd{\fpeval{floor(\varvalm,\DICHOTOstep)}}%
	\xdef\vartmpme{\fpeval{\vartmpmd+10**(-\DICHOTOstep)}}%
	%les variables créées
	\expandafter\def\csname#3d\endcsname{\fpeval{\vartmpmd}}%
	\expandafter\def\csname#3e\endcsname{\fpeval{\vartmpme}}%
	%valeur approchée
	\expandafter\def\csname#3a\endcsname{\fpeval{round(\varvalm,\DICHOTOstep)}}%
}


\endinput