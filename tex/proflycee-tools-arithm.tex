% proflycee-tools-arithm.tex
% Copyright 2023  Cédric Pierquet
% This work may be distributed and/or modified under the
% conditions of the LaTeX Project Public License, either version 1.3
% of this license or (at your option) any later version.
% The latest version of this license is in
%   http://www.latex-project.org/lppl.txt
% and version 1.3 or later is part of all distributions of LaTeX
% version 2005/12/01 or later.

\RequirePackage{ifthen}
\RequirePackage{modulus}

%%------ConversionsBases
%dec->bin avec blocs de 4 chiffres
\setKVdefault[CONVDECBIN]{%
	AffBase=true
}
\NewDocumentCommand\ConversionDecBin{ s O{} m }{%
	\useKVdefault[CONVDECBIN]
	\setKV[CONVDECBIN]{#2}% on paramètres les nouvelles clés et on les simplifie
	\def\resbrut{\xintDecToBin{#3}}%
	\StrLen{\resbrut}[\nbchiffres]%
	\def\nbgrp{\fpeval{4*ceil(\nbchiffres/4,0)}}%
	\IfBooleanTF{#1}%
		{\num{#3}\ifboolKV[CONVDECBIN]{AffBase}{_{10}}{}=\num[digit-group-size=4]{\resbrut}\ifboolKV[CONVDECBIN]{AffBase}{_{2}}{}}%
		{\num{#3}\ifboolKV[CONVDECBIN]{AffBase}{_{10}}{}=\num[digit-group-size=4,minimum-integer-digits=\nbgrp]{\resbrut}\ifboolKV[CONVDECBIN]{AffBase}{_{2}}{}}%
}

\setKVdefault[CONVBINHEX]{%
	%Epaisseur=0.75pt,%
	AffBase=true,%
	Details=true
}
%bourrage de 0 avant
\ExplSyntaxOn
\NewExpandableDocumentCommand{\PLstrzeros}{m}
{
	\int_compare:nT { #1 > 0 }
	{
		0 \prg_replicate:nn { #1 - 1 } { 0 }
	}
}
\ExplSyntaxOff


%la conversion complète
\newcommand\ConversionBinHex[2][]{%
	\useKVdefault[CONVBINHEX]%
	\setKV[CONVBINHEX]{#1}% on paramètres les nouvelles clés et on les simplifie
	\def\chbrut{#2}%
	\StrLen{\chbrut}[\nbchiffres]%nb de chiffres du binaire
	\xdef\nbgrp{\fpeval{4*ceil(\nbchiffres/4,0)}} %nb de chiffres avec blocs de 4
	\xdef\nbblocs{\fpeval{\nbgrp/4}} %nb de blocs
	%on rajoute des zeros si besoin := OK
	\xdef\resinter{\chbrut}%
	\num[digit-group-size=4]{\chbrut}\ifboolKV[CONVBINHEX]{AffBase}{_{2}}{}=%
	\ifboolKV[CONVBINHEX]{Details}{%
	\ifnum\nbchiffres<\nbgrp%
		\xdef\nbz{\inteval{\nbgrp-\nbchiffres}}%
		\xdef\resinter{\PLstrzeros{\nbz}\chbrut}%
		\num[digit-group-size=4,minimum-integer-digits=\nbgrp]{\resinter}=%
	\fi%
	%découpage par blocs et conversion en hexa := OK
	\newcount\cpt%
	\cpt0%
	\loop\ifnum \cpt<\nbblocs%
		\def\iinit{\fpeval{4*\cpt+1}}%
		\def\ifinal{\fpeval{4*(\cpt+1)}}%
		\StrMid{\resinter}{\iinit}{\ifinal}[\blocinter]%
		{\underbracket{\blocinter}_{\xintBinToHex{\blocinter}}\,}%
		\advance\cpt by 1%
	\repeat%
	\!=%
	}%
	{}%
	\xintBinToHex{\chbrut}\ifboolKV[CONVBINHEX]{AffBase}{_{16}}{}%
}

%hexa-bin par bloc de 4
\setKVdefault[CONVHEXBIN]{%
	%Epaisseur=0.75pt,
	AffBase=true,%
	Details=true
}

\newcommand\ConvHexBinBloc[1]{%
	\def\binbrut{\xintHexToBin{#1}}%
	\StrLen{\binbrut}[\nbchiffresbinbrut]%nb
	\PLstrzeros{\xinteval{4-\nbchiffresbinbrut}}{\binbrut}%
}

\newcommand\ConversionHexBin[2][]{%
	\useKVdefault[CONVHEXBIN]%
	\setKV[CONVHEXBIN]{#1}% on paramètres les nouvelles clés et on les simplifie
	%\def\thicktraitshexbin{\useKV[CONVHEXBIN]{Epaisseur}}%
	\ifboolKV[CONVHEXBIN]{AffBase}{#2_{16}=}{#2=}%
	\StrLen{#2}[\nbchiffreshex]%nb
	\ifboolKV[CONVHEXBIN]{Details}%
	{%
		\foreach \i in {1,...,\nbchiffreshex}{%
			\StrChar{#2}{\i}[\tmpcharhex]%
			{\underbracket{\ConvHexBinBloc{\tmpcharhex}}_{\tmpcharhex}\,}
		}%
		\ifboolKV[CONVHEXBIN]{AffBase}{{}_{2}}{}%
	}%
	{%
		\foreach \i in {1,...,\nbchiffreshex}{%
			\StrChar{#2}{\i}[\tmpcharhex]%
			\ConvHexBinBloc{\tmpcharhex}\,%
		}%
		\!\ifboolKV[CONVHEXBIN]{AffBase}{{}_{2}}{}%
	}%
}


%hexa/bin->dec avec écriture polynomiale
\defKV[CONVTODEC]{%
	BaseDep=\def\basedepart{#1}
}
\setKVdefault[CONVTODEC]{%
	BaseDep=2,%
	AffBase=true,%
	Details=true,%
	Zeros=true
}

\ExplSyntaxOn
\newcommand\convertbasetobasedix[2]{%
	\int_from_base:nn {#1}{#2}
}
\ExplSyntaxOff

\newcommand\ConversionVersDec[2][]{%
	\useKVdefault[CONVTODEC]
	\setKV[CONVTODEC]{#1}% on paramètres les nouvelles clés et on les simplifie
	\def\nbdepart{#2}%
	\StrLen{\nbdepart}[\nbchiffres]%
	\StrChar{\nbdepart}{1}[\chiffre]%
	%si on est en base 16
	\xintifboolexpr{\basedepart == 16}%
	{%
		\nbdepart\ifboolKV[CONVTODEC]{AffBase}{_{\basedepart}}{} =%
		\ifboolKV[CONVTODEC]{Details}{%
			\xintHexToDec{\chiffre}\times\basedepart^{\inteval{\nbchiffres-1}}%
			\newcount\cpt%
			\cpt2%
			\loop\ifnum \cpt<\inteval{\nbchiffres+1}%
				\def\puiss{\inteval{\nbchiffres-\cpt}}%
				\StrChar{\nbdepart}{\cpt}[\chiffre]%
				\ifboolKV[CONVTODEC]{Zeros}%
					{%
						+\xintHexToDec{\chiffre}\times\basedepart^{\puiss}%
					}%
					{%
						\ifnum\xintHexToDec{\chiffre} > 0%
							+\xintHexToDec{\chiffre}\times\basedepart^{\puiss}%
						\fi%
					}%
				\advance\cpt by 1%
			\repeat%
			=%
			}%
			{}%
		\num{\xintHexToDec{\nbdepart}}\ifboolKV[CONVTODEC]{AffBase}{_{10}}{}%
	}%
	{}%
	\xintifboolexpr{\basedepart == 2}%
	{%
		\num[digit-group-size=4]{\nbdepart}\ifboolKV[CONVTODEC]{AffBase}{_{\basedepart}}{} =%
		\ifboolKV[CONVTODEC]{Details}{%
			\chiffre\times\basedepart^{\inteval{\nbchiffres-1}}%
			\newcount\cpt%
			\cpt2%
			\loop\ifnum \cpt<\inteval{\nbchiffres+1}%
				\def\puiss{\inteval{\nbchiffres-\cpt}}%
				\StrChar{\nbdepart}{\cpt}[\chiffre]%
				\ifboolKV[CONVTODEC]{Zeros}%
				{%
					+\chiffre\times\basedepart^{\puiss}%
				}
				{
					\ifnum\chiffre > 0%
						+\chiffre\times\basedepart^{\puiss}%
					\fi%
				}%
			\advance\cpt by 1%
			\repeat%
			=%
			}%
			{}%
		\num{\xintBinToDec{\nbdepart}}\ifboolKV[CONVTODEC]{AffBase}{_{10}}{}%
	}%
	{}%
}

\newcommand\ConversionBaseDix[3][]{%1=options,%2=nb,%3=basedep ??
	\useKVdefault[CONVTODEC]
	\setKV[CONVTODEC]{#1}% on paramètres les nouvelles clés et on les simplifie
	\def\NBdepart{#2}%
	\def\basedepart{#3}%
	\StrLen{\NBdepart}[\nbchiffres]%
	\StrChar{\NBdepart}{1}[\chiffre]%
	\NBdepart\ifboolKV[CONVTODEC]{AffBase}{_{\basedepart}}{} =%
	\ifboolKV[CONVTODEC]{Details}{%
		\xintHexToDec{\chiffre}\times\basedepart^{\inteval{\nbchiffres-1}}%
		\newcount\cpt%
		\cpt2%
		\loop\ifnum \cpt<\inteval{\nbchiffres+1}%
			\def\puiss{\inteval{\nbchiffres-\cpt}}%
			\StrChar{\NBdepart}{\cpt}[\chiffre]%
			\ifboolKV[CONVTODEC]{Zeros}%
				{%
					+\xintHexToDec{\chiffre}\times\basedepart^{\puiss}%
				}%
				{%
					\ifnum\xintHexToDec{\chiffre} > 0%
						+\xintHexToDec{\chiffre}\times\basedepart^{\puiss}%
					\fi%
				}%
			\advance\cpt by 1%
		\repeat%
		=%
		}%
		{}%
	\num{\convertbasetobasedix{#2}{#3}}\ifboolKV[CONVTODEC]{AffBase}{_{10}}{}%
}

%%------CONVFROMDEC
\newcommand\PLnoeud[2]{\tikz[remember picture,baseline=(#1.base)]\node[shape=rectangle,inner sep=0pt](#1){#2};}
\ExplSyntaxOn
\newcommand\convertbasedixtobase[2]{%
	\int_to_Base:nn {#1}{#2}
}
\ExplSyntaxOff

\defKV[convfromten]{%
	Couleur=\def\PLConvCouleur{#1},%
	DecalH=\def\PLConvDecalH{#1},%
	DecalV=\def\PLConvDecalV{#1},%
	Noeud=\def\PLConvNoeud{#1}
}

\setKVdefault[convfromten]{%
	Couleur=red,%
	DecalH=2pt,%
	DecalV=3pt,%
	Rect=true,%
	Noeud=EEE,%
	CouleurRes=false
}

\newcommand\ConversionDepuisBaseDix[3][]{%
	\useKVdefault[convfromten]%
	\setKV[convfromten]{#1}%
	\xdef\ValRes{\xintDecToHex{#2}}%
	\xdef\ValA{#2}\xdef\ValB{#3}%
	\xdef\ValTMP{#2}%
	\xdef\ValMU{\inteval{#3-1}}%
	\ensuremath{%
		\left\lbrace\begin{array}{@{\,}r@{\;=\;}l@{\;+\;}r}
			%1ere division
			\xdef\ValQ{\fpeval{trunc(\ValTMP/#3,0)}}\xdef\ValR{\fpeval{\ValTMP-#3*\ValQ}}
			\num{\ValTMP}\uppercase{&}\num{\ValB}\times\num{\ValQ}\uppercase{&}\PLnoeud{\PLConvNoeud1}{\num{\ValR}}%
			\xdef\ValTMP{\ValQ}%
			\whiledo {\ValTMP > \ValMU}%
			{%
				\xdef\ValQ{\fpeval{trunc(\ValTMP/#3,0)}}\xdef\ValR{\fpeval{\ValTMP-#3*\ValQ}}%
				\\ \num{\ValTMP}\uppercase{&}\num{\ValB}\times\num{\ValQ}\uppercase{&}\num{\ValR}
				\xdef\ValTMP{\ValQ}%
			}
			%dernière
			\xdef\ValQ{\fpeval{trunc(\ValTMP/#3,0)}}\xdef\ValR{\fpeval{\ValTMP-#3*\ValQ}}%
			\\ \num{\ValTMP}\uppercase{&}\num{\ValB}\times\num{\ValQ}\uppercase{&}\PLnoeud{\PLConvNoeud2}{\num{\ValR}}%
		\end{array} \right| \Rightarrow \num{#2}_{10}=\ifboolKV[convfromten]{CouleurRes}{\mathcolor{\PLConvCouleur}{\convertbasedixtobase{#2}{#3}_{#3}}}{\convertbasedixtobase{#2}{#3}_{#3}}}%
	\ifboolKV[convfromten]{Rect}%
	{%
		\IfSubStr{\PLConvDecalH}{/}%
			{\StrCut{\PLConvDecalH}{/}{\PLConvDecalHg}{\PLConvDecalHd}}%
			{\def\PLConvDecalHg{\PLConvDecalH}\def\PLConvDecalHd{\PLConvDecalH}}%
		\begin{tikzpicture}
			\draw[overlay,rounded corners=4pt,\PLConvCouleur,thick] ($(\PLConvNoeud1.north west)+(-\PLConvDecalHg,\PLConvDecalV)$) rectangle ($(\PLConvNoeud2.south east)+(\PLConvDecalHd,-\PLConvDecalV)$) ;
			\draw[overlay,rounded corners=4pt,\PLConvCouleur,thick,->,>=latex] ($(\PLConvNoeud2.east)+(\PLConvDecalHd,0)$)--++(0,{0.75\baselineskip}) ;
		\end{tikzpicture}%
	}{}%
}

%%------PRESPGCD
\DeclareMathOperator{\PLpgcd}{PGCD}
\defKV[prespgcd]{%
	Couleur=\def\PLPGCDCouleur{#1},%
	DecalRect=\def\PLPGCDDecal{#1},%
	Noeud=\def\PLPGCDNoeud{#1}
}

\setKVdefault[prespgcd]{%
	Couleur=red,%
	DecalRect=2pt,%
	Rectangle=true,%
	Noeud=FFF,%
	CouleurResultat=false,%
	AfficheConclusion=true,%
	AfficheDelimiteurs=true
}

\RequirePackage{xintgcd}

\newcommand\PresentationPGCD[3][]{%
	\useKVdefault[prespgcd]%
	\setKV[prespgcd]{#1}%
	\xdef\respgcd{\xinteval{gcd(#2,#3)}}
	\xdef\ValA{#2}\xdef\ValB{#3}%on stocke les valeurs du départ
	\ensuremath{%
		\ifboolKV[prespgcd]{AfficheDelimiteurs}%
		{\left\lbrace}%
		{}%
		\begin{array}{@{\,}r@{\;=\;}l@{\;+\;}r}
			%1ère division
			\xdef\ValQ{\fpeval{trunc(\ValA/\ValB,0)}}\xdef\ValR{\fpeval{\ValA-\ValB*\ValQ}}%
			\num{\ValA}\uppercase{&}\num{\ValB}\times\num{\ValQ}\uppercase{&}%
			\xintifboolexpr{\ValR == \respgcd}%
			{\PLnoeud{\PLPGCDNoeud1}{\num{\ValR}}}%noeud si c'est le pgcd
			{\num{\ValR}}%
			\xdef\ValA{\ValB}\xdef\ValB{\ValR}%nouvelles valeurs
			\whiledo {\ValR > 0}%
			{%
				\xdef\ValQ{\fpeval{trunc(\ValA/\ValB,0)}}\xdef\ValR{\fpeval{\ValA-\ValB*\ValQ}}%
				\\%
				\num{\ValA}\uppercase{&}\num{\ValB}\times\num{\ValQ}\uppercase{&}%
				\xintifboolexpr{\ValR == \respgcd}%
				{\PLnoeud{\PLPGCDNoeud1}{\num{\ValR}}}%noeud si c'est le pgcd
				{\num{\ValR}}%
				\xdef\ValA{\ValB}\xdef\ValB{\ValR}%nouvelles valeurs
			}%
		\end{array}%
		\ifboolKV[prespgcd]{AfficheDelimiteurs}%
		{\right|}%
		{}%
		\ifboolKV[prespgcd]{AfficheConclusion}%
		{%
			\Rightarrow \PLpgcd\left(\num{#2};\num{#3}\right)=\ifboolKV[prespgcd]{CouleurResultat}{\mathcolor{\PLPGCDCouleur}{\num{\respgcd}}}{\num{\respgcd}}%
		}%
		{}%
	}%
	\ifboolKV[prespgcd]{Rectangle}%
	{%
		\begin{tikzpicture}
			\draw[overlay,rounded corners=4pt,\PLPGCDCouleur,thick] ($(\PLPGCDNoeud1.north west)+(-\PLPGCDDecal,\PLPGCDDecal)$) rectangle ($(\PLPGCDNoeud1.south east)+(\PLPGCDDecal,-\PLPGCDDecal)$) ;
		\end{tikzpicture}%
	}{}%
}

%%===égalité de Bezout
\NewDocumentCommand\AffCoeffBezout{ m }{%
	\xintifboolexpr{#1 < 0}%
		{\left( \num{#1} \right)}%
		{\num{#1}}%
}
\NewDocumentCommand\EgaliteBezout{ O{black} m m }{%
	\xintAssign{\xintBezout{#2}{#3}}\to\TmpU\TmpV\TmpD%
	\ensuremath{\num{#2} \times \mathcolor{#1}{\AffCoeffBezout{\TmpU}} + \AffCoeffBezout{#3} \times \mathcolor{#1}{\AffCoeffBezout{\TmpV}} = \num{\TmpD}}%
}

%%===Équations diophantiennes
\RequirePackage[thicklines]{cancel}%comme PfC
\NewDocumentCommand\AffCoeffDioph{ m }{%
	\xintifboolexpr{#1 < 0}%
		{\left( \num{#1} \right)}%
		{\num{#1}}%
}
\NewDocumentCommand\AffCoeffDiophSign{ m }{%
	\xintifboolexpr{#1 < 0}%
		{\num{#1}}%
		{+\num{#1}}%
}

\defKV[eqdioph]{%
	Lettre=\def\LettreSolEDioph{#1},%
	Couleur=\def\CouleurSolEDioph{#1},%
	Inconnues=\def\InconnuesSolEDioph{#1},%
	Entier=\def\KKK{#1}
}

\setKVdefault[eqdioph]{%
	Lettre=E,%
	Couleur=black,%
	Inconnues=x/y,%
	Entier=k,%
	Cadres=false,%
	PresPGCD=true
}

\NewDocumentCommand\EquationDiophantienne{ O{} m }{%v2 avec équation en "dur"
	\useKVdefault[eqdioph]%
	\setKV[eqdioph]{#1}%
	\setlength{\parindent}{0pt}%
	%extractions des paramètres
	\StrBefore[1]{\InconnuesSolEDioph}{/}[\XXX]%
	\StrBehind[1]{\InconnuesSolEDioph}{/}[\YYY]%
	\StrBefore{#2}{\XXX}[\AA]%
	\StrBetween{#2}{\XXX}{\YYY}[\BB]%
	\StrBehind{#2}{=}[\CC]%
	\IfStrEq{\AA}{}%
		{\def\AA{1}}{}%
	\IfStrEq{\AA}{-}%
		{\def\AA{-1}}{}%
	\StrLen{\BB}[\lgtB]%
	\xintifboolexpr{ \lgtB > 1 }%+b ou -b
		{%
			\StrDel{\BB}{+}[\BB]%
		}%
		{%
			\IfStrEq{\BB}{-}%
				{\def\BB{-1}}{}%
			\IfStrEq{\BB}{+}%
				{\def\BB{1}}{}%
		}%
	%Calcul du PGCD
	\xdef\PGCDD{\xinteval{gcd(\AA,\BB)}}%
	On cherche à résoudre l'équation diophantienne :\[ \num{\AA}\XXX + \AffCoeffDioph{\BB}\YYY=\num{\CC} \xintifboolexpr{ \PGCDD == 1 'or' \xintiiRem{\CC}{\PGCDD} != 0 }{\qquad (\LettreSolEDioph)}{} \]%
	\ifboolKV[eqdioph]{PresPGCD}%
		{D'après l'algorithme d'Euclide : \PresentationPGCD[Rectangle=false]{\xinteval{abs(\AA)}}{\xinteval{abs(\BB)}}.}%
		{Le PGCD de \num{\AA} et de \num{\BB} vaut \num{\PGCDD}.}%
	\par\smallskip
	\xintifboolexpr{ \xintiiRem{\CC}{\PGCDD} == 0 }%solutions obligatoires
		{%
			\xintifboolexpr{ \PGCDD == 1}%
				{%
					Les entiers \num{\xinteval{abs(\AA)}} et \num{\xinteval{abs(\BB)}} sont premiers entre eux, donc l'équation $(\LettreSolEDioph)$ admet une infinité de solutions.\par
					\xdef\AAA{\AA}\xdef\BBB{\BB}\xdef\CCC{\CC}%
				}%
				{%
					Le PGCD de \num{\AA} et \num{\BB} divise \num{\CC}, donc on peut simplifier l'équation diophantienne par \num{\PGCDD}.%
					\xdef\AAA{\xintiieval{\AA/\PGCDD}}\xdef\BBB{\xintiieval{\BB/\PGCDD}}\xdef\CCC{\xintiieval{\CC/\PGCDD}}%
					%
					\[ \num{\AA}\XXX+\AffCoeffDioph{\BB}\YYY=\num{\CC} \underset{\div\num{\PGCDD}}{\Longleftrightarrow} \num{\AAA}\XXX+\AffCoeffDioph{\BBB}\YYY=\num{\CCC} \qquad (\LettreSolEDioph) \]%
					Les entiers \num{\AAA} et \num{\BBB} sont premiers entre eux, donc l'équation $(\LettreSolEDioph)$ admet une infinité de solutions.\par
				}%
			\xintAssign{\xintBezout{\AAA}{\BBB}}\to\TmpU\TmpV\TmpD
			%
			On détermine une solution particulière de $(E)$ : \[ \num{\AAA} \times \mathcolor{\CouleurSolEDioph}{\AffCoeffBezout{\TmpU}} + \AffCoeffBezout{\BBB} \times \mathcolor{\CouleurSolEDioph}{\AffCoeffBezout{\TmpV}} = \num{\TmpD}
			\xintifboolexpr{ \CCC != 1}%
				{%
					\underset{\times\AffCoeffDioph{\CCC}}{\implies}
					\num{\AAA} \times \mathcolor{\CouleurSolEDioph}{\AffCoeffDioph{\xinteval{\TmpU*\CCC}}} + \AffCoeffBezout{\BBB} \times \mathcolor{\CouleurSolEDioph}{\AffCoeffDioph{\xinteval{\TmpV*\CCC}}} = \num{\CCC}
				}%
				{}%
				\qquad ({\LettreSolEDioph}_0)
			 \]%
			%
			Par soustraction :
			%
			\[%
			{\renewcommand\arraystretch{1.25}%
				\begin{array}{ @{\,} c @{\,} c @{\;\times\;} c @{\;+\;} c @{\;\times\;} c @{\;=\;} c }
					& \num{\AAA} & \XXX & \AffCoeffDioph{\BBB} & \YYY & \num{\CCC} \\
					-~~~~~ & \num{\AAA} & \mathcolor{\CouleurSolEDioph}{\AffCoeffDioph{\xinteval{\TmpU*\CCC}}} & \AffCoeffDioph{\BBB} & \mathcolor{\CouleurSolEDioph}{\AffCoeffDioph{\xinteval{\TmpV*\CCC}}} & \num{\CCC} \\ \hline
					& \num{\AAA} & \left( \XXX \mathcolor{\CouleurSolEDioph}{\AffCoeffDiophSign{\xinteval{-\TmpU*\CCC}}} \right)& \AffCoeffDioph{\BBB} & \left( \YYY \mathcolor{\CouleurSolEDioph}{\AffCoeffDiophSign{\xinteval{-\TmpV*\CCC}}} \right) & 0\\
				\end{array}}
			\]%
			\def\TmpPartieA{\XXX \mathcolor{\CouleurSolEDioph}{\AffCoeffDiophSign{\xinteval{-\TmpU*\CCC}}}}%
			\def\TmpPartieB{\YYY \mathcolor{\CouleurSolEDioph}{\AffCoeffDiophSign{\xinteval{-\TmpV*\CCC}}}}%
			%
			On en déduit que $\num{\AAA} \times \underbrace{\left( \TmpPartieA \right)}_{\text{entier}} = \num{\xinteval{-\BBB}} \times \left( \TmpPartieB \right)$, et donc que $\num{\AAA} \mid \num{\xinteval{-\BBB}} \times \left( \TmpPartieB \right)$.\par\smallskip
			Or \num{\xinteval{abs(\AAA)}} et \num{\xinteval{abs(\BBB)}} sont premiers entre eux, donc d'après le théorème de Gauss, on a $\num{\AAA} \mid \TmpPartieB$.\par
			Il existe donc un entier $\KKK$ tel que $\TmpPartieB = \num{\AAA} \times \KKK$, ce qui donne 
			$\ifboolKV[eqdioph]{Cadres}
				{\boxed{\YYY = \mathcolor{\CouleurSolEDioph}{\num{\xinteval{\CCC*\TmpV}}}  \AffCoeffDiophSign{\AAA}\KKK}}
				{\YYY = \mathcolor{\CouleurSolEDioph}{\num{\xinteval{\CCC*\TmpV}}}  \AffCoeffDiophSign{\AAA}\KKK}
			$.\par
			En remplaçant, on obtient :
			%
			\begin{align*}
				\num{\AAA} \times \left( \TmpPartieA \right) = \num{\xinteval{-\BBB}} \times \left( \TmpPartieB \right) & \implies \num{\AAA} \times \left( \TmpPartieA \right) = \num{\xinteval{-\BBB}} \times \big( \underbrace{\mathcolor{\CouleurSolEDioph}{\num{\xinteval{\CCC*\TmpV}}} \AffCoeffDiophSign{\AAA}\KKK}_{\mathclap{\YYY}}  \mathcolor{\CouleurSolEDioph}{\AffCoeffDiophSign{\xinteval{-\CCC*\TmpV}}} \big) \\
				& \implies \num{\AAA} \times \left( \TmpPartieA \right) = \num{\xinteval{-\BBB}} \times \left( \num{\AAA}\KKK \right) \\
				& \implies \TmpPartieA = \num{\xinteval{-\BBB}}\KKK \\
				& \implies \ifboolKV[eqdioph]{Cadres}
					{\boxed{\XXX = \mathcolor{\CouleurSolEDioph}{\num{\xinteval{\CCC*\TmpU}}} \AffCoeffDiophSign{\xinteval{-\BBB}}\KKK}}
					{\XXX = \mathcolor{\CouleurSolEDioph}{\num{\xinteval{\CCC*\TmpU}}} \AffCoeffDiophSign{\xinteval{-\BBB}}\KKK}
			\end{align*}
			%
			Ainsi, si $\XXX$ et $\YYY$ sont solutions de $(\LettreSolEDioph)$, alors il existe un entier $\KKK$ tel que ${\XXX=\mathcolor{\CouleurSolEDioph}{\num{\xinteval{\CCC*\TmpU}}} \AffCoeffDiophSign{\xinteval{-\BBB}}\KKK}$ et ${\YYY=\mathcolor{\CouleurSolEDioph}{\num{\xinteval{\CCC*\TmpV}}}  \AffCoeffDiophSign{\AAA}\KKK}$.\par\medskip
			Réciproquement, soit $\KKK$ un entier quelconque :
			%
			\begin{align*}
				\num{\AAA} \times \left( \mathcolor{\CouleurSolEDioph}{\num{\xinteval{\CCC*\TmpU}}} \AffCoeffDiophSign{\xinteval{-\BBB}}\KKK \right) + \AffCoeffDioph{\BBB} \times  \left( \mathcolor{\CouleurSolEDioph}{\num{\xinteval{\CCC*\TmpV}}}  \AffCoeffDiophSign{\AAA}\KKK \right) & = \num{\AAA} \times \mathcolor{\CouleurSolEDioph}{\AffCoeffDioph{\xinteval{\CCC*\TmpU}}} + \cancel{\AffCoeffDioph{\AAA} \times \AffCoeffDioph{\xinteval{-\BBB}} \KKK} + \AffCoeffDioph{\BBB} \times \mathcolor{\CouleurSolEDioph}{\AffCoeffDioph{\xinteval{\CCC*\TmpV}}} +  \cancel{\AffCoeffDioph{\BBB} \times \AffCoeffDioph{\AAA} \KKK} \\
				& = \underbrace{\num{\AAA} \times \mathcolor{\CouleurSolEDioph}{\AffCoeffDioph{\xinteval{\CCC*\TmpU}}} +  \AffCoeffDioph{\BBB} \times \mathcolor{\CouleurSolEDioph}{\AffCoeffDioph{\xinteval{\CCC*\TmpV}}}}_{=\,\num{\CCC} \text{ d'après } ({\LettreSolEDioph}_0)} \\
				& = \num{\CCC}
			\end{align*}
			%
			On en déduit que $\left(\mathcolor{\CouleurSolEDioph}{\num{\xinteval{\CCC*\TmpU}}} \AffCoeffDiophSign{\xinteval{-\BBB}}\KKK \mathpunct{}; \mathcolor{\CouleurSolEDioph}{\num{\xinteval{\CCC*\TmpV}}}  \AffCoeffDiophSign{\AAA}\KKK \right)$ est solution de $(\LettreSolEDioph)$.\par\medskip
			En conclusion, les solutions de $(E)$ sont donc les couples $\left(\mathcolor{\CouleurSolEDioph}{\num{\xinteval{\CCC*\TmpU}}} \AffCoeffDiophSign{\xinteval{-\BBB}}\KKK \mathpunct{}; \mathcolor{\CouleurSolEDioph}{\num{\xinteval{\CCC*\TmpV}}} \AffCoeffDiophSign{\AAA}\KKK \right)$, avec $\KKK$ un entier relatif.
		}%
		{%
			Le PGCD de \num{\AA} et \num{\BB} ne divise pas \num{\CC}, donc l'équation $(\LettreSolEDioph)$ n'admet aucune solution.
		}%
}

%liste diviseurs
\setKVdefault[listdiv]{%
	AffNom=true
}
\NewDocumentCommand\ListeDiviseurs{ s O{} m }{%
	\useKVdefault[listdiv]%
	\setKV[listdiv]{#2}%
	\xdef\tmplistdiv{1}%
	\xdef\argcal{\xinteval{#3}}%
	\xintFor* ##1 in {\xintSeq{2}{\argcal}}\do{%
		\xintifboolexpr{ \xintiiRem{\argcal}{##1} == 0 }%
		{%
			\xdef\tmplistdiv{\tmplistdiv /\num{##1}}
		}%
		{}%
	}%
	\ensuremath{\ifboolKV[listdiv]{AffNom}{\IfBooleanTF{#1}{\mathscr{D}}{\mathcal{D}}_{\num{\argcal}}=}{}\EcritureEnsemble[\strut]{\tmplistdiv}}
}

%arbre diviseurs
\defKV[arbrediviseurs]{%
	EspaceNiveau=\def\TmpEspNiv{#1},%
	EspaceFeuille=\def\TMpEspFeuille{#1},%
	CouleurDetails=\def\TmpCoulDetails{#1},%
	Echelle=\def\TmpEchelle{#1}
}

\setKVdefault[arbrediviseurs]{%
	EspaceNiveau=2.25,%
	EspaceFeuille=0.66,%
	Details=true,%
	CouleurDetails=red,%
	Echelle=1,%
	Fleches=true
}

\NewDocumentCommand\ArbreDiviseurs{ O{} m }{%
	\useKVdefault[arbrediviseurs]%
	\setKV[arbrediviseurs]{#1}%
	% test avec CPoulain ^^
	\xdef\tmpcalc{\xinteval{#2}}%
	\xdef\tmparg{}%
	\newcount\anp\newcount\bnp\newcount\cnp%
	\newcount\pileb\newcount\exposant%
	\exposant=0\relax%
	\anp=\tmpcalc\relax%
	\bnp=2\relax%
	\pileb=2\relax%
	\whiledo{\the\anp > 1}{%
		\modulo{\the\anp}{\the\bnp}%
		\ifnum\remainder=0\relax%
		\cnp=\numexpr\anp/\bnp\relax%
		\exposant=\numexpr\exposant+1\relax%
		\anp=\cnp\relax%
		\else%
		\ifnum\exposant>0\relax%
		\xdef\tmparg{\tmparg\the\pileb,\the\exposant*}%
		%\expandafter\UpdatetoksCPier\Foo\nil%
		\fi%
		\bnp=\numexpr\bnp+1\relax%
		\pileb=\bnp\relax%
		\exposant=0\relax%
		\fi%
	}%
	\xdef\tmparg{\tmparg\the\bnp,{\the\exposant}}%
	%\expandafter\UpdatetoksCPier\the\bnp,{\the\exposant}\nil%
	% \xdef\argnum{\xinteval{#2}}%
	% \def\decompotmp{\DecompoPremierExposant{#2}}%
	\setsepchar{*/,}%
	\xdef\Foo{\tmparg}%
	\readlist*\readcaractdiv{\Foo}%
	% fin test CPoulain ^^
	\xdef\arbredivnbdivprem{\readcaractdivlen}%nombre diviseurs permiers
	\xdef\arbredivnbdiv{1}%
	\xintFor* ##1 in {\xintSeq{1}{\arbredivnbdivprem}}\do{\xdef\arbredivnbdiv{\xinteval{\arbredivnbdiv*(\readcaractdiv[##1,2]+1)}}}%nombre diviseurs
	\def\HauteurTotale{\xinteval{\arbredivnbdiv-1}}%
	\ifboolKV[arbrediviseurs]{Fleches}%
	{\tikzstyle{flechearbrediv} = [line width=\fpeval{\TmpEchelle*0.6}pt,->,>=latex]}%
	{\tikzstyle{flechearbrediv} = [line width=\fpeval{\TmpEchelle*0.6}pt]}%
	\begin{tikzpicture}[scale=\TmpEchelle,every node/.style={scale=\TmpEchelle}]
		% grille d'aide
		% \draw[xstep=\TmpEspNiv,ystep=\TMpEspFeuille,thin,lightgray] (0,{(-\arbredivnbdiv+1)*\TMpEspFeuille}) grid ({\arbredivnbdivprem*\TmpEspNiv},0) ;
		% dernier niveau OK
		\xdef\nbsommets{\arbredivnbdiv}%
		\xintFor* ##1 in {\xintSeq{1}{\nbsommets}}\do%
		{%
			\itemtomacro\readcaractdiv[\arbredivnbdivprem,2]\tmppuiss%
			\xdef\tmpdiv{\xinteval{\tmppuiss+1}}%
			\node[outer sep=0pt] (N-\arbredivnbdivprem-##1) at ({\arbredivnbdivprem*\TmpEspNiv},{-(##1-1)*\TMpEspFeuille}) {$\num{\readcaractdiv[\arbredivnbdivprem,1]}^{\xinteval{\xintiiRem{\xinteval{##1-1}}{\tmpdiv}}}$} ;%
		}
		% niveaux suivants, en descendant
		\xintFor* ##2 in {\xintSeq{\arbredivnbdivprem-1}{1}}\do%
		{%
			\xdef\nbsommets{\xintieval{\nbsommets/(\readcaractdiv[##2+1,2]+1)}}%
			\xdef\espacementsommets{\xinteval{\arbredivnbdiv/(\nbsommets)}}%
			\xdef\OffsetNiveau{\xintieval{(\HauteurTotale-(\nbsommets-1)*\espacementsommets)}}%
			\xintFor* ##3 in {\xintSeq{1}{\nbsommets}}\do%
			{%
				\itemtomacro\readcaractdiv[##2,2]\tmppuiss%
				\xdef\tmpdiv{\xinteval{\tmppuiss+1}}%
				\node[outer sep=0pt] (N-##2-##3) at ({##2*\TmpEspNiv},{(-(##3-1)*\espacementsommets-0.5*\OffsetNiveau)*\TMpEspFeuille}) {$\num{\readcaractdiv[##2,1]}^{\xinteval{\xintiiRem{\xinteval{##3-1}}{\tmpdiv}}}$} ;
			}%
		}%
		% racine
		\coordinate (Racine) at ({0},{-0.5*(\arbredivnbdiv-1)*(\TMpEspFeuille)}) ;
		% \draw (Racine) node {$\Omega$} ;
		% les flèches, qui partent de la racine
		\xintFor* ##4 in {\xintSeq{1}{\xinteval{\readcaractdiv[1,2]+1}}}\do%
		{%
			\draw[flechearbrediv] (Racine) -- (N-1-##4) ;
		}%
		% les flèches successives
		\foreach \nivdep in {1,...,\xinteval{\arbredivnbdivprem-1}}%
		{%
			\xdef\nbsommetsniv{1}%
			\foreach \i in {1,...,\nivdep}{\xdef\nbsommetsniv{\xinteval{\nbsommetsniv*(\readcaractdiv[\i,2]+1)}}}%calcul du nombre de sommets de départ
			% boucle sur sommets de départ
			\foreach \numsom in {1,...,\nbsommetsniv}%
			{%
				\xdef\nivplusun{\xinteval{\nivdep+1}}%
				\foreach \nbsousbranches in {1,...,\xinteval{\readcaractdiv[\nivplusun,2]+1}}%
				{%
					\xdef\sumsomarriv{\xinteval{ (\readcaractdiv[\nivplusun,2]+1)*(\numsom-1) + \nbsousbranches }}%
					\draw[flechearbrediv] (N-\nivdep-\numsom) -- (N-\nivplusun-\sumsomarriv) ;
				}
			}%
		}%
		\ifboolKV[arbrediviseurs]{Details}%
		{%
			% essai de génération des calculs := ouaiissssss
			\foreach \i in {1,...,\arbredivnbdiv}{%
				\xdef\resdiv{1}%
				% on extrait la premiere puissance := on obtient la répartition ?
				\itemtomacro\readcaractdiv[-1,2]\tmppuiss\xdef\tmpdiv{\xinteval{(\tmppuiss+1)}}%
				% création de la liste des puissances !!
				\xdef\calculdiviseur{\num{\readcaractdiv[-1,1]}^{\xinteval{\xintiiRem{\xinteval{\i-1}}{\tmpdiv}}}}%
				\xdef\resdiv{\xinteval{\resdiv*(\readcaractdiv[-1,1])^(\xinteval{\xintiiRem{\xinteval{\i-1}}{\tmpdiv}})}}%
				% on complète avec les autres parties ??
				\foreach \nbprem in {2,...,\arbredivnbdivprem}{%
					% il reste à stocker les produits des puissances, en descendant... erf.....
					\xdef\tmppuisscumul{1}%
					\foreach \k in {1,...,\xinteval{\nbprem-1}}{%
						\itemtomacro\readcaractdiv[-\k,2]\tmppuissrepet%
						\xdef\tmppuisscumul{\xinteval{\tmppuisscumul*(\tmppuissrepet+1)}}%
					}%
					\itemtomacro\readcaractdiv[-\nbprem,2]\tmppuiss%
					\xdef\tmpdivniv{\xinteval{(\tmppuiss+1)}}%
					% \xdef\tmpdiv{\xinteval{(\tmppuissrepet+1)}}%
					\xdef\calculdiviseur{\num{\readcaractdiv[-\nbprem,1]}^{\xinteval{\xintiiRem{\xintieval{trunc((\i-1)/(\tmppuisscumul),0)}}{\tmpdivniv}}}\times\calculdiviseur}%
					\xdef\resdiv{\xinteval{\resdiv*(\readcaractdiv[-\nbprem,1])^(\xinteval{\xintiiRem{\xintieval{trunc((\i-1)/(\tmppuisscumul),0)}}{\tmpdivniv}})}}%
				}%
				\draw ([xshift=1cm]N-\arbredivnbdivprem-\i) node[right,\TmpCoulDetails] {$\calculdiviseur=\num{\resdiv}$} ;
			}%
		}{}%
	\end{tikzpicture}%
}

%somme des chiffres
\ifthenelse{\isundefined{\SommeChiffres}}%
	{%
		\NewDocumentCommand\SommeChiffres{ m }{%
			\StrLen{#1}[\nbchiffres]%
			\xdef\tmpres{0}%
			\foreach \i in {1,...,\nbchiffres}{\StrChar{#1}{\i}[\tmpchf]\xdef\tmpres{\xinteval{\tmpres+\tmpchf}}}%
			\ensuremath{\num{\tmpres}}%
		}
	}%
	{%
		\RenewDocumentCommand\SommeChiffres{ m }{%
			\StrLen{#1}[\nbchiffres]%
			\xdef\tmpres{0}%
			\foreach \i in {1,...,\nbchiffres}{\StrChar{#1}{\i}[\tmpchf]\xdef\tmpres{\xinteval{\tmpres+\tmpchf}}}%
			\ensuremath{\num{\tmpres}}%
		}
	}%

\endinput